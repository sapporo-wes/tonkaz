import { crate, main, utils } from "./mod.ts";
import { asciiTable, color, datetime, emoji } from "./deps.ts";

export const DEFAULT_THRESHOLD = 0.05;
export const OUTPUTS_ID_PREFIX_RE = new RegExp(`^outputs/`);

export function compare(
  crate1: crate.Crate,
  crate2: crate.Crate,
  all = false,
  threshold: number = DEFAULT_THRESHOLD,
  json = false,
): void {
  crate1.summarize();
  crate2.summarize();
  const c1OutputsIds = all
    ? crate1.summary.outputs
    : crate1.summary.outputsWithEdam;
  const c2OutputsIds = all
    ? crate2.summary.outputs
    : crate2.summary.outputsWithEdam;
  const compareResult = compareFiles(
    crate1,
    crate2,
    c1OutputsIds,
    c2OutputsIds,
    threshold,
  );

  if (!json) {
    renderFirstMsg(crate1, crate2);
    renderSummaryTable(crate1, crate2);
    renderEdamExt();
    renderRepLevelExplanation(all, threshold);
    renderCompareResult(compareResult, crate1, crate2, threshold);
  } else {
    renderJson(compareResult);
  }
}

export function renderFirstMsg(crate1: crate.Crate, crate2: crate.Crate): void {
  console.log(`\
Tonkaz ${main.TonkazVersion}

${color.green("Checking")} Crate2 based on Crate1:

  Crate1: ${color.cyan(crate1.location)}
  Crate2: ${color.cyan(crate2.location)}
`);
}

export function renderSummaryTable(
  crate1: crate.Crate,
  crate2: crate.Crate,
): void {
  const ellipseVal = (val: string) => {
    if (val.length <= 36) return val;
    return val.slice(0, 10) + " ... " + val.slice(-21);
  };

  // alignFuncs
  const a1 = (val: string) => asciiTable.default.alignLeft(val, 14, " ");
  const a23Header = (val: string) =>
    asciiTable.default.alignCenter(val, 36, " ");
  const a23 = (val: string) =>
    asciiTable.default.alignLeft(ellipseVal(val), 36, " ");

  const data: asciiTable.AsciiData = {
    title: "",
    heading: [a1(""), a23Header("Crate1"), a23Header("Crate2")],
    rows: [],
  };

  const headerKeys: [string, keyof crate.CrateSummary][] = [
    ["WF Name", "wfName"],
    ["WF ID", "wfId"],
    ["WF Version", "wfVersion"],
    ["WF Type", "wfType"],
    ["WF TypeVersion", "wfTypeVersion"],
    ["Run Name", "testId"],
    ["Run State", "state"],
    ["ExitCode", "exitCode"],
    ["Start Time", "startTime"],
    ["End Time", "endTime"],
    ["Duration", "duration"],
    ["# Attachments", "wfAttachments"],
    ["# Intermediate", "intermediateFiles"],
    ["# Outputs", "outputs"],
    ["# Outputs with EDAM", "outputsWithEdam"],
  ];

  headerKeys.forEach(([header, key]) => {
    header = a1(header);
    if (header.includes("#")) {
      if (key === "outputsWithEdam") {
        // do nothing
      } else {
        data.rows.push([
          header,
          ...utils.warningColor(
            [crate1, crate2].map((c) => {
              const val = `${(c.summary[key] as string[]).length} files${
                key === "outputs"
                  ? ` (${c.summary.outputsWithEdam.length} EDAM-assigned files)`
                  : ""
              }`;
              return a23(val);
            }),
          ),
        ]);
      }
    } else if (header.includes("Time")) {
      data.rows.push([
        header,
        ...[crate1, crate2].map((c) => {
          const val = c.summary[key] != undefined
            ? datetime.format(c.summary[key] as Date, "yyyy-MM-dd HH:mm:ss")
            : "";
          return a23(val);
        }),
      ]);
    } else if (key === "duration") {
      data.rows.push([
        header,
        ...[crate1, crate2].map((c) => {
          let val = "";
          if (c.summary[key] != undefined) {
            const duration = c.summary[key] as ReturnType<
              typeof datetime.difference
            >;
            val = utils.formatDuration(duration);
          }
          return a23(val);
        }),
      ]);
    } else {
      data.rows.push([
        header,
        ...utils.warningColor(
          [crate1, crate2].map((c) => {
            const val = c.summary[key] != undefined
              ? ellipseVal(`${c.summary[key]}`)
              : "";
            return a23(val);
          }),
        ),
      ]);
    }
  });

  const table = asciiTable.default.fromJSON(data);
  console.log(utils.ourTableToString(table));
}

export function renderEdamExt(): void {
  const ext = Object.keys(crate.EDAM_MAPPING);
  console.log(`  * EDAM extensions: ${ext.join("/")}`);
  console.log(""); // empty line
}

// generated by compareFiles
export interface CompareResult {
  bothIds: string[];
  onlyCrate1Ids: string[]; // ReproducibilityLevel.NO_FILE
  onlyCrate2Ids: string[]; // ReproducibilityLevel.NO_FILE
  level3Ids: string[]; // ReproducibilityLevel.SAME_CHECKSUM
  level2Ids: string[]; // ReproducibilityLevel.SIMILAR_FEATURES
  level1Ids: string[]; // ReproducibilityLevel.DIFFERENT_FEATURES
}

// Result file reproducibility level is:
//
// level3. same checksum
// level2. checksum are different, but its features (file size, map rate, etc.) are similar (within threshold)
// level1. checksum are different, and its features are different (beyond threshold)
// level0. file not found
export enum ReproducibilityLevel {
  SAME_CHECKSUM = 3,
  SIMILAR_FEATURES = 2,
  DIFFERENT_FEATURES = 1,
  NO_FILE = 0,
}

export function compareFiles(
  crate1: crate.Crate,
  crate2: crate.Crate,
  ids1: string[],
  ids2: string[],
  threshold: number,
): CompareResult {
  const compareResult = {
    bothIds: [] as string[],
    onlyCrate1Ids: [] as string[],
    onlyCrate2Ids: [] as string[],
    level3Ids: [] as string[],
    level2Ids: [] as string[],
    level1Ids: [] as string[],
    level0Ids: [] as string[],
  };

  compareResult.bothIds = utils.intersection(ids1, ids2);
  compareResult.onlyCrate1Ids = utils.difference(ids1, ids2);
  compareResult.onlyCrate2Ids = utils.difference(ids2, ids1);

  const stats = compareResult.bothIds.map((id) => {
    return {
      id,
      c1: crate1.findEntity(id).stats(),
      c2: crate2.findEntity(id).stats(),
    };
  });
  stats.forEach((s) => {
    const level = compareSummary(s.c1, s.c2, threshold);
    switch (level) {
      case ReproducibilityLevel.SAME_CHECKSUM:
        compareResult.level3Ids.push(s.id);
        break;
      case ReproducibilityLevel.SIMILAR_FEATURES:
        compareResult.level2Ids.push(s.id);
        break;
      case ReproducibilityLevel.DIFFERENT_FEATURES:
        compareResult.level1Ids.push(s.id);
        break;
      default:
        throw new Error(`Unexpected reproducibility level: ${level}`);
    }
  });

  return compareResult;
}

export function compareSummary(
  s1: crate.FileStats,
  s2: crate.FileStats,
  threshold: number,
): ReproducibilityLevel {
  let level: ReproducibilityLevel;
  if (s1.checksum === s2.checksum) {
    level = ReproducibilityLevel.SAME_CHECKSUM;
  } else {
    level = ReproducibilityLevel.SIMILAR_FEATURES;

    const updateLevel = (
      level: ReproducibilityLevel,
      val1: number | undefined,
      val2: number | undefined,
    ): ReproducibilityLevel => {
      if (val1 == undefined && val2 == undefined) {
        return level;
      } else {
        const newLevel = compareSummaryContent(val1, val2, threshold);
        return Math.min(level, newLevel);
      }
    };

    const keys = Object.keys(s1) as (keyof crate.FileStats)[];
    keys.forEach((k) => {
      if (k === "checksum" || k == "duration") {
        // do nothing
      } else if (k === "contentSize" || k == "lineCount") {
        level = updateLevel(level, s1[k], s2[k]);
      } else if (k === "samtoolsStats") {
        const [s1Sam, s2Sam] = [s1, s2].map((s) => s.samtoolsStats);
        if (s1Sam != undefined && s2Sam != undefined) {
          (
            ["totalReads", "mappedReads", "duplicateReads"] as Array<
              keyof crate.SamtoolsStats
            >
          ).forEach((k2) => {
            level = updateLevel(level, s1Sam[k2], s2Sam[k2]);
          });
        }
      } else if (k === "vcftoolsStats") {
        const [s1Vcf, s2Vcf] = [s1, s2].map((s) => s.vcftoolsStats);
        if (s1Vcf != undefined && s2Vcf != undefined) {
          (
            ["variantCount", "snpsCount", "indelsCount"] as Array<
              keyof crate.VcftoolsStats
            >
          ).forEach((k2) => {
            level = updateLevel(level, s1Vcf[k2], s2Vcf[k2]);
          });
        }
      }
    });
  }

  return level;
}

export function compareSummaryContent(
  val1: number | undefined,
  val2: number | undefined,
  threshold: number,
): ReproducibilityLevel {
  if (val1 == undefined && val2 == undefined) {
    throw new Error("Both values are undefined");
  }
  if (val1 == undefined || val2 == undefined) {
    return ReproducibilityLevel.DIFFERENT_FEATURES;
  }
  if (Math.abs(val1 - val2) / val1 <= threshold) {
    return ReproducibilityLevel.SIMILAR_FEATURES;
  } else {
    return ReproducibilityLevel.DIFFERENT_FEATURES;
  }
}

const STAR = emoji.get("star");
const LEVEL_EXP = {
  3: "Files are identical with the same checksum",
  2: "Files are different, but their features (file size, map rate, etc.) are similar (within threshold)",
  1: "Files are different, and their features are different (beyond threshold)",
  0: "File not found",
};

export function renderRepLevelExplanation(
  all: boolean,
  threshold: number,
): void {
  console.log(`${color.green("Comparing")} workflow results...`);
  if (!all) {
    console.log(
      "Calculate the reproducibility level by comparing the EDAM-assigned output files of Crate1 and Crate2. (option `--all` to use all output files)",
    );
  } else {
    console.log(
      "Calculate the reproducibility level by comparing the output files of Crate1 and Crate2.",
    );
  }
  console.log(""); // empty line
  console.log("Reproducibility level is defined as follows:");
  console.log(""); // empty line

  const levels: Array<keyof typeof LEVEL_EXP> = Object.keys(LEVEL_EXP)
    .map((k) => parseInt(k) as keyof typeof LEVEL_EXP)
    .sort()
    .reverse();
  levels.forEach((l) => {
    console.log(
      `  - ${color.blue(`Level${l}`)} ${STAR.repeat(l)}${
        "  ".repeat(
          3 - l,
        )
      } : ${
        l === 2
          ? LEVEL_EXP[l].replace("threshold", `threshold: ${threshold}`)
          : LEVEL_EXP[l]
      }`,
    );
  });

  console.log(""); // empty line
  console.log(
    `  ${color.blue("Level3")}: "Fully Reproduced" <---> ${
      color.blue(
        "Level0",
      )
    }: "Not Reproduced"`,
  );
  console.log("");
}

export function renderCompareResult(
  result: CompareResult,
  crate1: crate.Crate,
  crate2: crate.Crate,
  threshold: number,
): void {
  renderLevel3Files(result);
  renderLevel2Files(result, crate1, crate2, threshold);
  renderLevel1Files(result, crate1, crate2, threshold);
  renderLevel0Files(result);

  renderCompareSummary(result);
}

export function renderLevel3Files(result: CompareResult): void {
  console.log(
    `=== ${color.blue("Level3")} ${
      STAR.repeat(3)
    } (Same Checksum, ${result.level3Ids.length}/${result.bothIds.length} files)`,
  );
  console.log(""); // empty line

  const ids = result.level3Ids
    .map((id) => id.replace(OUTPUTS_ID_PREFIX_RE, ""))
    .sort();
  if (ids.length > 0) {
    ids.forEach((id) => {
      console.log(`  - ${id}`);
    });
    console.log(""); // empty line
  }
}

export function renderLevel2Files(
  result: CompareResult,
  crate1: crate.Crate,
  crate2: crate.Crate,
  threshold: number,
): void {
  console.log(
    `=== ${color.blue("Level2")} ${
      STAR.repeat(2)
    } (Similar Features, ${result.level2Ids.length}/${result.bothIds.length} files)`,
  );
  console.log(""); // empty line

  const ids = result.level2Ids.sort();
  ids.forEach((id) => {
    renderFileStats(id, crate1, crate2, threshold, OUTPUTS_ID_PREFIX_RE);
  });
}

export function renderLevel1Files(
  result: CompareResult,
  crate1: crate.Crate,
  crate2: crate.Crate,
  threshold: number,
): void {
  console.log(
    `=== ${color.blue("Level1")} ${
      STAR.repeat(1)
    } (Different Features, ${result.level1Ids.length}/${result.bothIds.length} files)`,
  );
  console.log(""); // empty line

  const ids = result.level1Ids.sort();
  ids.forEach((id) => {
    renderFileStats(id, crate1, crate2, threshold, OUTPUTS_ID_PREFIX_RE);
  });
}

export function renderLevel0Files(result: CompareResult): void {
  console.log(
    `=== ${
      color.blue("Level0")
    } (Not Found, Crate1: ${result.onlyCrate1Ids.length} files, Crate2: ${result.onlyCrate2Ids.length} files)`,
  );
  console.log(""); // empty line

  const ids1 = result.onlyCrate1Ids.sort();
  if (ids1.length > 0) {
    console.log("  - Only in Crate1:");
    console.log(""); // empty line
    ids1.forEach((id) => {
      console.log(`    - ${id}`);
    });
    console.log(""); // empty line
  }

  const ids2 = result.onlyCrate2Ids.sort();
  if (ids2.length > 0) {
    console.log("  - Only in Crate2:");
    console.log(""); // empty line
    ids2.forEach((id) => {
      console.log(`    - ${id}`);
    });
    console.log(""); // empty line
  }
}

export function renderFileStats(
  id: string,
  crate1: crate.Crate,
  crate2: crate.Crate,
  threshold: number,
  trim_prefix_regex: RegExp,
): void {
  const e1 = crate1.findEntity(id);
  const e2 = crate2.findEntity(id);
  const s1 = e1.stats();
  const s2 = e2.stats();

  // alignFuncs
  const a1 = (val: string) => asciiTable.default.alignLeft(val, 14, " ");
  const a23Header = (val: string) =>
    asciiTable.default.alignCenter(val, 23, " ");
  const a23 = (val: string) => asciiTable.default.alignLeft(val, 23, " ");

  const data: asciiTable.AsciiData = {
    title: "",
    heading: [a1(""), a23Header("in Crate1"), a23Header("in Crate2")],
    rows: [],
  };

  // compareVal -> format -> align -> colorized
  const appendRow = (
    header: string,
    val1: number | undefined,
    val2: number | undefined,
    formatFunc: typeof outToString = outToString,
    arg1: number | undefined = undefined,
    arg2: number | undefined = undefined,
  ): void => {
    const result = compareSummaryContent(val1, val2, threshold);
    let formattedVal1 = a23(formatFunc(val1, arg1));
    let formattedVal2 = a23(formatFunc(val2, arg2));
    if (result === ReproducibilityLevel.DIFFERENT_FEATURES) {
      formattedVal1 = color.red(formattedVal1);
      formattedVal2 = color.red(formattedVal2);
    } else if (result === ReproducibilityLevel.SIMILAR_FEATURES) {
      if (val1 == val2) {
        // do nothing => same value
      } else {
        formattedVal1 = color.yellow(formattedVal1);
        formattedVal2 = color.yellow(formattedVal2);
      }
    }
    data.rows.push([a1(header), formattedVal1, formattedVal2]);
  };

  appendRow("File Size", s1.contentSize, s2.contentSize, utils.formatFileSize);
  if (s1.lineCount != undefined && s2.lineCount != undefined) {
    appendRow("Line Count", s1.lineCount, s2.lineCount);
  }

  if (s1.samtoolsStats != undefined || s2.samtoolsStats != undefined) {
    crate.SAM_HEADER_KEYS.forEach(([header, key]) => {
      if (key == "totalReads") {
        appendRow(header, s1.samtoolsStats?.[key], s2.samtoolsStats?.[key]);
      } else {
        // key == "mappedReads", "duplicateReads"
        const s1Read = s1.samtoolsStats?.[key];
        const s1Rate = s1.samtoolsStats?.[
          key.replace("Reads", "Rate") as keyof crate.SamtoolsStats
        ];
        const s2Read = s2.samtoolsStats?.[key];
        const s2Rate = s2.samtoolsStats?.[
          key.replace("Reads", "Rate") as keyof crate.SamtoolsStats
        ];
        const appendRate = (
          read: number | undefined,
          rate: number | undefined,
        ): string => {
          if (read == undefined) return "-";
          if (rate == undefined) return `${read}`;
          return `${read} (${(rate * 100).toFixed(2)}%)`;
        };
        appendRow(header, s1Read, s2Read, appendRate, s1Rate, s2Rate);
      }
    });
  }

  if (s1.vcftoolsStats != undefined || s2.vcftoolsStats != undefined) {
    crate.VCF_HEADER_KEYS.forEach(([header, key]) => {
      appendRow(header, s1.vcftoolsStats?.[key], s2.vcftoolsStats?.[key]);
    });
  }

  const table = asciiTable.default.fromJSON(data);

  console.log(`  - ${id.replace(trim_prefix_regex, "")}`);
  console.log(
    utils.tablePaddingLeft(utils.ourTableToString(table), 4),
  );
  console.log(""); // empty line
}

export function outToString(
  val: number | undefined,
  _extra: number | undefined,
): string {
  return val == undefined ? "-" : `${val}`;
}

export function appendLineUnderGeneralMetadata(table: string): string {
  // append line under general metadata (Line Count or File Size)
  const lines = table.split("\n");
  if (lines.length < 8) {
    return table;
  }
  const line = lines[2];
  const lineCountIndex = lines.findIndex((l) => l.includes("Line Count"));
  const contentSizeIndex = lines.findIndex((l) => l.includes("File Size"));
  const insertIndex = lineCountIndex > -1 ? lineCountIndex : contentSizeIndex;
  const insertedLines = [
    ...lines.slice(0, insertIndex + 1),
    line,
    ...lines.slice(insertIndex + 1),
  ];
  return insertedLines.join("\n");
}

export function renderJson(compareResult: CompareResult): void {
  console.log(JSON.stringify(compareResult, null, 2));
}

export function renderCompareSummary(compareResult: CompareResult): void {
  // alignFuncs
  const aHeader = (val: string, len: number) =>
    asciiTable.default.alignCenter(val, len, " ");
  const a = (val: string, len: number) =>
    asciiTable.default.alignLeft(val, len, " ");
  const col1Len = 9;
  const col2Len = 25;
  const col3Len = 19;
  const col4Len = 11;

  const data: asciiTable.AsciiData = {
    title: "",
    heading: [
      aHeader("Reproducibility", col2Len),
      aHeader("Level", col1Len),
      aHeader("Definition", col3Len),
      aHeader("File #", col4Len),
    ],
    rows: [],
  };

  const addRow = (c1: number, c2: string, c3: string, c4: number): void => {
    data.rows.push([
      a(c2, col2Len),
      a(STAR.repeat(c1), col1Len - c1),
      a(c3, col3Len),
      a(`${c4} files`, col4Len),
    ]);
  };

  addRow(
    3,
    "Fully Reproduced",
    "Same Checksum",
    compareResult.level3Ids.length,
  );
  addRow(
    2,
    "Acceptable Differences",
    "Similar Features",
    compareResult.level2Ids.length,
  );
  addRow(
    1,
    "Unacceptable Differences",
    "Different Features",
    compareResult.level1Ids.length,
  );
  addRow(
    0,
    "Not Reproduced",
    "Not Found",
    compareResult.onlyCrate1Ids.length + compareResult.onlyCrate2Ids.length,
  );

  console.log(`${color.green("Summarize")} compare result:`);
  console.log(""); // empty line
  const table = asciiTable.default.fromJSON(data);
  console.log(utils.tablePaddingLeft(utils.ourTableToString(table), 2));
  console.log(""); // empty line
}
